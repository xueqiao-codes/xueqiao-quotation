/**
 * Autogenerated by Thrift Compiler (0.9.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "quotation_account_types.h"

#include <algorithm>



int _kQuotationTechPlatformValues[] = {
  QuotationTechPlatform::NONE,
  QuotationTechPlatform::CTP,
  QuotationTechPlatform::ESUNNY
};
const char* _kQuotationTechPlatformNames[] = {
  "NONE",
  "CTP",
  "ESUNNY"
};
const std::map<int, const char*> _QuotationTechPlatform_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kQuotationTechPlatformValues, _kQuotationTechPlatformNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kQuotationPlatformEnvValues[] = {
  QuotationPlatformEnv::NONE,
  QuotationPlatformEnv::REAL,
  QuotationPlatformEnv::SIM
};
const char* _kQuotationPlatformEnvNames[] = {
  "NONE",
  "REAL",
  "SIM"
};
const std::map<int, const char*> _QuotationPlatformEnv_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kQuotationPlatformEnvValues, _kQuotationPlatformEnvNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kQuotationAccountStateValues[] = {
  QuotationAccountState::ACCOUNT_DISABLED,
  QuotationAccountState::ACCOUNT_ENABLED
};
const char* _kQuotationAccountStateNames[] = {
  "ACCOUNT_DISABLED",
  "ACCOUNT_ENABLED"
};
const std::map<int, const char*> _QuotationAccountState_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kQuotationAccountStateValues, _kQuotationAccountStateNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kQuotationAccountAccessStateValues[] = {
  QuotationAccountAccessState::ACCOUNT_NOT_ACCESS,
  QuotationAccountAccessState::ACCOUNT_ACTIVE,
  QuotationAccountAccessState::ACCOUNT_INVALID
};
const char* _kQuotationAccountAccessStateNames[] = {
  "ACCOUNT_NOT_ACCESS",
  "ACCOUNT_ACTIVE",
  "ACCOUNT_INVALID"
};
const std::map<int, const char*> _QuotationAccountAccessState_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kQuotationAccountAccessStateValues, _kQuotationAccountAccessStateNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kSupportTypeValues[] = {
  SupportType::SET,
  SupportType::ALL
};
const char* _kSupportTypeNames[] = {
  "SET",
  "ALL"
};
const std::map<int, const char*> _SupportType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kSupportTypeValues, _kSupportTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kQuotationAccountOrderByValues[] = {
  QuotationAccountOrderBy::ACCOUNT_ID,
  QuotationAccountOrderBy::CREATE_TIMESTAMP
};
const char* _kQuotationAccountOrderByNames[] = {
  "ACCOUNT_ID",
  "CREATE_TIMESTAMP"
};
const std::map<int, const char*> _QuotationAccountOrderBy_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kQuotationAccountOrderByValues, _kQuotationAccountOrderByNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

const char* ContractActiveRule::ascii_fingerprint = "F9ABDD47113EC6C5C8979A836E3E653E";
const uint8_t ContractActiveRule::binary_fingerprint[16] = {0xF9,0xAB,0xDD,0x47,0x11,0x3E,0xC6,0xC5,0xC8,0x97,0x9A,0x83,0x6E,0x3E,0x65,0x3E};

uint32_t ContractActiveRule::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->sledCommodityId);
          this->__isset.sledCommodityId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->activeMonthMap.clear();
            uint32_t _size0;
            ::apache::thrift::protocol::TType _ktype1;
            ::apache::thrift::protocol::TType _vtype2;
            xfer += iprot->readMapBegin(_ktype1, _vtype2, _size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              int32_t _key5;
              xfer += iprot->readI32(_key5);
              bool& _val6 = this->activeMonthMap[_key5];
              xfer += iprot->readBool(_val6);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.activeMonthMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->createTimestamp);
          this->__isset.createTimestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lastModityTimestamp);
          this->__isset.lastModityTimestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ContractActiveRule::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ContractActiveRule");

  if (this->__isset.sledCommodityId) {
    xfer += oprot->writeFieldBegin("sledCommodityId", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->sledCommodityId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.activeMonthMap) {
    xfer += oprot->writeFieldBegin("activeMonthMap", ::apache::thrift::protocol::T_MAP, 2);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_BOOL, static_cast<uint32_t>(this->activeMonthMap.size()));
      std::map<int32_t, bool> ::const_iterator _iter7;
      for (_iter7 = this->activeMonthMap.begin(); _iter7 != this->activeMonthMap.end(); ++_iter7)
      {
        xfer += oprot->writeI32(_iter7->first);
        xfer += oprot->writeBool(_iter7->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.createTimestamp) {
    xfer += oprot->writeFieldBegin("createTimestamp", ::apache::thrift::protocol::T_I64, 6);
    xfer += oprot->writeI64(this->createTimestamp);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.lastModityTimestamp) {
    xfer += oprot->writeFieldBegin("lastModityTimestamp", ::apache::thrift::protocol::T_I64, 7);
    xfer += oprot->writeI64(this->lastModityTimestamp);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ContractActiveRule &a, ContractActiveRule &b) {
  using ::std::swap;
  swap(a.sledCommodityId, b.sledCommodityId);
  swap(a.activeMonthMap, b.activeMonthMap);
  swap(a.createTimestamp, b.createTimestamp);
  swap(a.lastModityTimestamp, b.lastModityTimestamp);
  swap(a.__isset, b.__isset);
}

const char* ContractRegisterRule::ascii_fingerprint = "B77C06788DC1780F1D7637240029A71D";
const uint8_t ContractRegisterRule::binary_fingerprint[16] = {0xB7,0x7C,0x06,0x78,0x8D,0xC1,0x78,0x0F,0x1D,0x76,0x37,0x24,0x00,0x29,0xA7,0x1D};

uint32_t ContractRegisterRule::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->sledCommodityId);
          this->__isset.sledCommodityId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->registerPriority);
          this->__isset.registerPriority = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->activeShowCount);
          this->__isset.activeShowCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->inactiveShowCount);
          this->__isset.inactiveShowCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast8;
          xfer += iprot->readI32(ecast8);
          this->platformEnv = (QuotationPlatformEnv::type)ecast8;
          this->__isset.platformEnv = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->createTimestamp);
          this->__isset.createTimestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lastModityTimestamp);
          this->__isset.lastModityTimestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->orderIndex);
          this->__isset.orderIndex = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ContractRegisterRule::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ContractRegisterRule");

  if (this->__isset.sledCommodityId) {
    xfer += oprot->writeFieldBegin("sledCommodityId", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->sledCommodityId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.registerPriority) {
    xfer += oprot->writeFieldBegin("registerPriority", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->registerPriority);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.activeShowCount) {
    xfer += oprot->writeFieldBegin("activeShowCount", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->activeShowCount);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.inactiveShowCount) {
    xfer += oprot->writeFieldBegin("inactiveShowCount", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->inactiveShowCount);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.platformEnv) {
    xfer += oprot->writeFieldBegin("platformEnv", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32((int32_t)this->platformEnv);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.createTimestamp) {
    xfer += oprot->writeFieldBegin("createTimestamp", ::apache::thrift::protocol::T_I64, 6);
    xfer += oprot->writeI64(this->createTimestamp);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.lastModityTimestamp) {
    xfer += oprot->writeFieldBegin("lastModityTimestamp", ::apache::thrift::protocol::T_I64, 7);
    xfer += oprot->writeI64(this->lastModityTimestamp);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.orderIndex) {
    xfer += oprot->writeFieldBegin("orderIndex", ::apache::thrift::protocol::T_I32, 8);
    xfer += oprot->writeI32(this->orderIndex);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ContractRegisterRule &a, ContractRegisterRule &b) {
  using ::std::swap;
  swap(a.sledCommodityId, b.sledCommodityId);
  swap(a.registerPriority, b.registerPriority);
  swap(a.activeShowCount, b.activeShowCount);
  swap(a.inactiveShowCount, b.inactiveShowCount);
  swap(a.platformEnv, b.platformEnv);
  swap(a.createTimestamp, b.createTimestamp);
  swap(a.lastModityTimestamp, b.lastModityTimestamp);
  swap(a.orderIndex, b.orderIndex);
  swap(a.__isset, b.__isset);
}

const char* CommodityRegisterOrder::ascii_fingerprint = "95563430298FDCCE431FC73A024A159D";
const uint8_t CommodityRegisterOrder::binary_fingerprint[16] = {0x95,0x56,0x34,0x30,0x29,0x8F,0xDC,0xCE,0x43,0x1F,0xC7,0x3A,0x02,0x4A,0x15,0x9D};

uint32_t CommodityRegisterOrder::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->sledCommodityId);
          this->__isset.sledCommodityId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast9;
          xfer += iprot->readI32(ecast9);
          this->platformEnv = (QuotationPlatformEnv::type)ecast9;
          this->__isset.platformEnv = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->orderIndex);
          this->__isset.orderIndex = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CommodityRegisterOrder::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CommodityRegisterOrder");

  if (this->__isset.sledCommodityId) {
    xfer += oprot->writeFieldBegin("sledCommodityId", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->sledCommodityId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.platformEnv) {
    xfer += oprot->writeFieldBegin("platformEnv", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32((int32_t)this->platformEnv);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.orderIndex) {
    xfer += oprot->writeFieldBegin("orderIndex", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->orderIndex);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CommodityRegisterOrder &a, CommodityRegisterOrder &b) {
  using ::std::swap;
  swap(a.sledCommodityId, b.sledCommodityId);
  swap(a.platformEnv, b.platformEnv);
  swap(a.orderIndex, b.orderIndex);
  swap(a.__isset, b.__isset);
}

const char* QuotationAccount::ascii_fingerprint = "4AEE290289C3B4661303609E5988FFFC";
const uint8_t QuotationAccount::binary_fingerprint[16] = {0x4A,0xEE,0x29,0x02,0x89,0xC3,0xB4,0x66,0x13,0x03,0x60,0x9E,0x59,0x88,0xFF,0xFC};

uint32_t QuotationAccount::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->accountId);
          this->__isset.accountId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->accountName);
          this->__isset.accountName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->accountpwd);
          this->__isset.accountpwd = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nickName);
          this->__isset.nickName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast10;
          xfer += iprot->readI32(ecast10);
          this->platform = (QuotationTechPlatform::type)ecast10;
          this->__isset.platform = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->brokerId);
          this->__isset.brokerId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->brokerAccessId);
          this->__isset.brokerAccessId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->accountProperties.clear();
            uint32_t _size11;
            ::apache::thrift::protocol::TType _ktype12;
            ::apache::thrift::protocol::TType _vtype13;
            xfer += iprot->readMapBegin(_ktype12, _vtype13, _size11);
            uint32_t _i15;
            for (_i15 = 0; _i15 < _size11; ++_i15)
            {
              std::string _key16;
              xfer += iprot->readString(_key16);
              std::string& _val17 = this->accountProperties[_key16];
              xfer += iprot->readString(_val17);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.accountProperties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast18;
          xfer += iprot->readI32(ecast18);
          this->accountState = (QuotationAccountState::type)ecast18;
          this->__isset.accountState = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast19;
          xfer += iprot->readI32(ecast19);
          this->accessState = (QuotationAccountAccessState::type)ecast19;
          this->__isset.accessState = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->invalidReason);
          this->__isset.invalidReason = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->invalidErrorCode);
          this->__isset.invalidErrorCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->apiRetCode);
          this->__isset.apiRetCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxRegisterCount);
          this->__isset.maxRegisterCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->createTimestamp);
          this->__isset.createTimestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lastModifyTimestamp);
          this->__isset.lastModifyTimestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast20;
          xfer += iprot->readI32(ecast20);
          this->platformEnv = (QuotationPlatformEnv::type)ecast20;
          this->__isset.platformEnv = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t QuotationAccount::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("QuotationAccount");

  if (this->__isset.accountId) {
    xfer += oprot->writeFieldBegin("accountId", ::apache::thrift::protocol::T_I64, 1);
    xfer += oprot->writeI64(this->accountId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.accountName) {
    xfer += oprot->writeFieldBegin("accountName", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->accountName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.accountpwd) {
    xfer += oprot->writeFieldBegin("accountpwd", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->accountpwd);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.nickName) {
    xfer += oprot->writeFieldBegin("nickName", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->nickName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.platform) {
    xfer += oprot->writeFieldBegin("platform", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32((int32_t)this->platform);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.brokerId) {
    xfer += oprot->writeFieldBegin("brokerId", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32(this->brokerId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.brokerAccessId) {
    xfer += oprot->writeFieldBegin("brokerAccessId", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32(this->brokerAccessId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.accountProperties) {
    xfer += oprot->writeFieldBegin("accountProperties", ::apache::thrift::protocol::T_MAP, 8);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->accountProperties.size()));
      std::map<std::string, std::string> ::const_iterator _iter21;
      for (_iter21 = this->accountProperties.begin(); _iter21 != this->accountProperties.end(); ++_iter21)
      {
        xfer += oprot->writeString(_iter21->first);
        xfer += oprot->writeString(_iter21->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.accountState) {
    xfer += oprot->writeFieldBegin("accountState", ::apache::thrift::protocol::T_I32, 9);
    xfer += oprot->writeI32((int32_t)this->accountState);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.accessState) {
    xfer += oprot->writeFieldBegin("accessState", ::apache::thrift::protocol::T_I32, 10);
    xfer += oprot->writeI32((int32_t)this->accessState);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.invalidReason) {
    xfer += oprot->writeFieldBegin("invalidReason", ::apache::thrift::protocol::T_STRING, 11);
    xfer += oprot->writeString(this->invalidReason);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.invalidErrorCode) {
    xfer += oprot->writeFieldBegin("invalidErrorCode", ::apache::thrift::protocol::T_I32, 12);
    xfer += oprot->writeI32(this->invalidErrorCode);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.apiRetCode) {
    xfer += oprot->writeFieldBegin("apiRetCode", ::apache::thrift::protocol::T_I32, 13);
    xfer += oprot->writeI32(this->apiRetCode);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.maxRegisterCount) {
    xfer += oprot->writeFieldBegin("maxRegisterCount", ::apache::thrift::protocol::T_I32, 14);
    xfer += oprot->writeI32(this->maxRegisterCount);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.createTimestamp) {
    xfer += oprot->writeFieldBegin("createTimestamp", ::apache::thrift::protocol::T_I64, 15);
    xfer += oprot->writeI64(this->createTimestamp);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.lastModifyTimestamp) {
    xfer += oprot->writeFieldBegin("lastModifyTimestamp", ::apache::thrift::protocol::T_I64, 16);
    xfer += oprot->writeI64(this->lastModifyTimestamp);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.platformEnv) {
    xfer += oprot->writeFieldBegin("platformEnv", ::apache::thrift::protocol::T_I32, 17);
    xfer += oprot->writeI32((int32_t)this->platformEnv);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(QuotationAccount &a, QuotationAccount &b) {
  using ::std::swap;
  swap(a.accountId, b.accountId);
  swap(a.accountName, b.accountName);
  swap(a.accountpwd, b.accountpwd);
  swap(a.nickName, b.nickName);
  swap(a.platform, b.platform);
  swap(a.brokerId, b.brokerId);
  swap(a.brokerAccessId, b.brokerAccessId);
  swap(a.accountProperties, b.accountProperties);
  swap(a.accountState, b.accountState);
  swap(a.accessState, b.accessState);
  swap(a.invalidReason, b.invalidReason);
  swap(a.invalidErrorCode, b.invalidErrorCode);
  swap(a.apiRetCode, b.apiRetCode);
  swap(a.maxRegisterCount, b.maxRegisterCount);
  swap(a.createTimestamp, b.createTimestamp);
  swap(a.lastModifyTimestamp, b.lastModifyTimestamp);
  swap(a.platformEnv, b.platformEnv);
  swap(a.__isset, b.__isset);
}

const char* MicSupportCommodity::ascii_fingerprint = "E185935EF111C75062AE5EC509759A8E";
const uint8_t MicSupportCommodity::binary_fingerprint[16] = {0xE1,0x85,0x93,0x5E,0xF1,0x11,0xC7,0x50,0x62,0xAE,0x5E,0xC5,0x09,0x75,0x9A,0x8E};

uint32_t MicSupportCommodity::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast22;
          xfer += iprot->readI32(ecast22);
          this->supportType = (SupportType::type)ecast22;
          this->__isset.supportType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->supportCommodityIds.clear();
            uint32_t _size23;
            ::apache::thrift::protocol::TType _etype26;
            xfer += iprot->readSetBegin(_etype26, _size23);
            uint32_t _i27;
            for (_i27 = 0; _i27 < _size23; ++_i27)
            {
              int32_t _elem28;
              xfer += iprot->readI32(_elem28);
              this->supportCommodityIds.insert(_elem28);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.supportCommodityIds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MicSupportCommodity::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("MicSupportCommodity");

  if (this->__isset.supportType) {
    xfer += oprot->writeFieldBegin("supportType", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32((int32_t)this->supportType);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.supportCommodityIds) {
    xfer += oprot->writeFieldBegin("supportCommodityIds", ::apache::thrift::protocol::T_SET, 2);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->supportCommodityIds.size()));
      std::set<int32_t> ::const_iterator _iter29;
      for (_iter29 = this->supportCommodityIds.begin(); _iter29 != this->supportCommodityIds.end(); ++_iter29)
      {
        xfer += oprot->writeI32((*_iter29));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MicSupportCommodity &a, MicSupportCommodity &b) {
  using ::std::swap;
  swap(a.supportType, b.supportType);
  swap(a.supportCommodityIds, b.supportCommodityIds);
  swap(a.__isset, b.__isset);
}

const char* QuotationAccountSupport::ascii_fingerprint = "2EB0F666D9064C192875B5056E5351A4";
const uint8_t QuotationAccountSupport::binary_fingerprint[16] = {0x2E,0xB0,0xF6,0x66,0xD9,0x06,0x4C,0x19,0x28,0x75,0xB5,0x05,0x6E,0x53,0x51,0xA4};

uint32_t QuotationAccountSupport::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->accountId);
          this->__isset.accountId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->micSupport.clear();
            uint32_t _size30;
            ::apache::thrift::protocol::TType _ktype31;
            ::apache::thrift::protocol::TType _vtype32;
            xfer += iprot->readMapBegin(_ktype31, _vtype32, _size30);
            uint32_t _i34;
            for (_i34 = 0; _i34 < _size30; ++_i34)
            {
              std::string _key35;
              xfer += iprot->readString(_key35);
              MicSupportCommodity& _val36 = this->micSupport[_key35];
              xfer += _val36.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.micSupport = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t QuotationAccountSupport::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("QuotationAccountSupport");

  if (this->__isset.accountId) {
    xfer += oprot->writeFieldBegin("accountId", ::apache::thrift::protocol::T_I64, 1);
    xfer += oprot->writeI64(this->accountId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.micSupport) {
    xfer += oprot->writeFieldBegin("micSupport", ::apache::thrift::protocol::T_MAP, 2);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->micSupport.size()));
      std::map<std::string, MicSupportCommodity> ::const_iterator _iter37;
      for (_iter37 = this->micSupport.begin(); _iter37 != this->micSupport.end(); ++_iter37)
      {
        xfer += oprot->writeString(_iter37->first);
        xfer += _iter37->second.write(oprot);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(QuotationAccountSupport &a, QuotationAccountSupport &b) {
  using ::std::swap;
  swap(a.accountId, b.accountId);
  swap(a.micSupport, b.micSupport);
  swap(a.__isset, b.__isset);
}

const char* ReqQuotationAccountSupportOption::ascii_fingerprint = "FF23ED08C38253C1C2A7B9DFAE86EBD8";
const uint8_t ReqQuotationAccountSupportOption::binary_fingerprint[16] = {0xFF,0x23,0xED,0x08,0xC3,0x82,0x53,0xC1,0xC2,0xA7,0xB9,0xDF,0xAE,0x86,0xEB,0xD8};

uint32_t ReqQuotationAccountSupportOption::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->accountIds.clear();
            uint32_t _size38;
            ::apache::thrift::protocol::TType _etype41;
            xfer += iprot->readSetBegin(_etype41, _size38);
            uint32_t _i42;
            for (_i42 = 0; _i42 < _size38; ++_i42)
            {
              int64_t _elem43;
              xfer += iprot->readI64(_elem43);
              this->accountIds.insert(_elem43);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.accountIds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ReqQuotationAccountSupportOption::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ReqQuotationAccountSupportOption");

  if (this->__isset.accountIds) {
    xfer += oprot->writeFieldBegin("accountIds", ::apache::thrift::protocol::T_SET, 1);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->accountIds.size()));
      std::set<int64_t> ::const_iterator _iter44;
      for (_iter44 = this->accountIds.begin(); _iter44 != this->accountIds.end(); ++_iter44)
      {
        xfer += oprot->writeI64((*_iter44));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ReqQuotationAccountSupportOption &a, ReqQuotationAccountSupportOption &b) {
  using ::std::swap;
  swap(a.accountIds, b.accountIds);
  swap(a.__isset, b.__isset);
}

const char* QuotationAccountSupportPage::ascii_fingerprint = "EEE6495FE96ECC4A976F643BCA21EFD3";
const uint8_t QuotationAccountSupportPage::binary_fingerprint[16] = {0xEE,0xE6,0x49,0x5F,0xE9,0x6E,0xCC,0x4A,0x97,0x6F,0x64,0x3B,0xCA,0x21,0xEF,0xD3};

uint32_t QuotationAccountSupportPage::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->total);
          this->__isset.total = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->page.clear();
            uint32_t _size45;
            ::apache::thrift::protocol::TType _etype48;
            xfer += iprot->readListBegin(_etype48, _size45);
            this->page.resize(_size45);
            uint32_t _i49;
            for (_i49 = 0; _i49 < _size45; ++_i49)
            {
              xfer += this->page[_i49].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.page = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t QuotationAccountSupportPage::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("QuotationAccountSupportPage");

  if (this->__isset.total) {
    xfer += oprot->writeFieldBegin("total", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->total);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.page) {
    xfer += oprot->writeFieldBegin("page", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->page.size()));
      std::vector<QuotationAccountSupport> ::const_iterator _iter50;
      for (_iter50 = this->page.begin(); _iter50 != this->page.end(); ++_iter50)
      {
        xfer += (*_iter50).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(QuotationAccountSupportPage &a, QuotationAccountSupportPage &b) {
  using ::std::swap;
  swap(a.total, b.total);
  swap(a.page, b.page);
  swap(a.__isset, b.__isset);
}

const char* AccountCommodityRegisterAbility::ascii_fingerprint = "682071CAC217C3A03351891C9195CEC7";
const uint8_t AccountCommodityRegisterAbility::binary_fingerprint[16] = {0x68,0x20,0x71,0xCA,0xC2,0x17,0xC3,0xA0,0x33,0x51,0x89,0x1C,0x91,0x95,0xCE,0xC7};

uint32_t AccountCommodityRegisterAbility::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->registerAbilityId);
          this->__isset.registerAbilityId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->accountId);
          this->__isset.accountId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->sledExchangeId);
          this->__isset.sledExchangeId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->exchangeMic);
          this->__isset.exchangeMic = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast51;
          xfer += iprot->readI32(ecast51);
          this->supportType = (SupportType::type)ecast51;
          this->__isset.supportType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->sledCommodityId);
          this->__isset.sledCommodityId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->createTimestamp);
          this->__isset.createTimestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lastModifyTimestamp);
          this->__isset.lastModifyTimestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccountCommodityRegisterAbility::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccountCommodityRegisterAbility");

  if (this->__isset.registerAbilityId) {
    xfer += oprot->writeFieldBegin("registerAbilityId", ::apache::thrift::protocol::T_I64, 1);
    xfer += oprot->writeI64(this->registerAbilityId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.accountId) {
    xfer += oprot->writeFieldBegin("accountId", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->accountId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sledExchangeId) {
    xfer += oprot->writeFieldBegin("sledExchangeId", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->sledExchangeId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.exchangeMic) {
    xfer += oprot->writeFieldBegin("exchangeMic", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->exchangeMic);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.supportType) {
    xfer += oprot->writeFieldBegin("supportType", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32((int32_t)this->supportType);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sledCommodityId) {
    xfer += oprot->writeFieldBegin("sledCommodityId", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32(this->sledCommodityId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.createTimestamp) {
    xfer += oprot->writeFieldBegin("createTimestamp", ::apache::thrift::protocol::T_I64, 7);
    xfer += oprot->writeI64(this->createTimestamp);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.lastModifyTimestamp) {
    xfer += oprot->writeFieldBegin("lastModifyTimestamp", ::apache::thrift::protocol::T_I64, 8);
    xfer += oprot->writeI64(this->lastModifyTimestamp);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AccountCommodityRegisterAbility &a, AccountCommodityRegisterAbility &b) {
  using ::std::swap;
  swap(a.registerAbilityId, b.registerAbilityId);
  swap(a.accountId, b.accountId);
  swap(a.sledExchangeId, b.sledExchangeId);
  swap(a.exchangeMic, b.exchangeMic);
  swap(a.supportType, b.supportType);
  swap(a.sledCommodityId, b.sledCommodityId);
  swap(a.createTimestamp, b.createTimestamp);
  swap(a.lastModifyTimestamp, b.lastModifyTimestamp);
  swap(a.__isset, b.__isset);
}

const char* AccountCommodityRegisterAbilityPage::ascii_fingerprint = "991FF82DB820DF5442A17666E44B129A";
const uint8_t AccountCommodityRegisterAbilityPage::binary_fingerprint[16] = {0x99,0x1F,0xF8,0x2D,0xB8,0x20,0xDF,0x54,0x42,0xA1,0x76,0x66,0xE4,0x4B,0x12,0x9A};

uint32_t AccountCommodityRegisterAbilityPage::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->total);
          this->__isset.total = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->page.clear();
            uint32_t _size52;
            ::apache::thrift::protocol::TType _etype55;
            xfer += iprot->readListBegin(_etype55, _size52);
            this->page.resize(_size52);
            uint32_t _i56;
            for (_i56 = 0; _i56 < _size52; ++_i56)
            {
              xfer += this->page[_i56].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.page = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccountCommodityRegisterAbilityPage::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccountCommodityRegisterAbilityPage");

  if (this->__isset.total) {
    xfer += oprot->writeFieldBegin("total", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->total);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.page) {
    xfer += oprot->writeFieldBegin("page", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->page.size()));
      std::vector<AccountCommodityRegisterAbility> ::const_iterator _iter57;
      for (_iter57 = this->page.begin(); _iter57 != this->page.end(); ++_iter57)
      {
        xfer += (*_iter57).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AccountCommodityRegisterAbilityPage &a, AccountCommodityRegisterAbilityPage &b) {
  using ::std::swap;
  swap(a.total, b.total);
  swap(a.page, b.page);
  swap(a.__isset, b.__isset);
}

const char* ReqAccountCommodityRegisterAbilityOption::ascii_fingerprint = "FAF7A330CA050ED1E40CD2DE8EB9000A";
const uint8_t ReqAccountCommodityRegisterAbilityOption::binary_fingerprint[16] = {0xFA,0xF7,0xA3,0x30,0xCA,0x05,0x0E,0xD1,0xE4,0x0C,0xD2,0xDE,0x8E,0xB9,0x00,0x0A};

uint32_t ReqAccountCommodityRegisterAbilityOption::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->registerAbilityId);
          this->__isset.registerAbilityId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->accountId);
          this->__isset.accountId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->sledCommodityIds.clear();
            uint32_t _size58;
            ::apache::thrift::protocol::TType _etype61;
            xfer += iprot->readSetBegin(_etype61, _size58);
            uint32_t _i62;
            for (_i62 = 0; _i62 < _size58; ++_i62)
            {
              int32_t _elem63;
              xfer += iprot->readI32(_elem63);
              this->sledCommodityIds.insert(_elem63);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.sledCommodityIds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->sledExchangeIds.clear();
            uint32_t _size64;
            ::apache::thrift::protocol::TType _etype67;
            xfer += iprot->readSetBegin(_etype67, _size64);
            uint32_t _i68;
            for (_i68 = 0; _i68 < _size64; ++_i68)
            {
              int32_t _elem69;
              xfer += iprot->readI32(_elem69);
              this->sledExchangeIds.insert(_elem69);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.sledExchangeIds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast70;
          xfer += iprot->readI32(ecast70);
          this->supportType = (SupportType::type)ecast70;
          this->__isset.supportType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->exchangeMics.clear();
            uint32_t _size71;
            ::apache::thrift::protocol::TType _etype74;
            xfer += iprot->readSetBegin(_etype74, _size71);
            uint32_t _i75;
            for (_i75 = 0; _i75 < _size71; ++_i75)
            {
              std::string _elem76;
              xfer += iprot->readString(_elem76);
              this->exchangeMics.insert(_elem76);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.exchangeMics = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ReqAccountCommodityRegisterAbilityOption::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ReqAccountCommodityRegisterAbilityOption");

  if (this->__isset.registerAbilityId) {
    xfer += oprot->writeFieldBegin("registerAbilityId", ::apache::thrift::protocol::T_I64, 1);
    xfer += oprot->writeI64(this->registerAbilityId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.accountId) {
    xfer += oprot->writeFieldBegin("accountId", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->accountId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sledCommodityIds) {
    xfer += oprot->writeFieldBegin("sledCommodityIds", ::apache::thrift::protocol::T_SET, 3);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->sledCommodityIds.size()));
      std::set<int32_t> ::const_iterator _iter77;
      for (_iter77 = this->sledCommodityIds.begin(); _iter77 != this->sledCommodityIds.end(); ++_iter77)
      {
        xfer += oprot->writeI32((*_iter77));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sledExchangeIds) {
    xfer += oprot->writeFieldBegin("sledExchangeIds", ::apache::thrift::protocol::T_SET, 4);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->sledExchangeIds.size()));
      std::set<int32_t> ::const_iterator _iter78;
      for (_iter78 = this->sledExchangeIds.begin(); _iter78 != this->sledExchangeIds.end(); ++_iter78)
      {
        xfer += oprot->writeI32((*_iter78));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.supportType) {
    xfer += oprot->writeFieldBegin("supportType", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32((int32_t)this->supportType);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.exchangeMics) {
    xfer += oprot->writeFieldBegin("exchangeMics", ::apache::thrift::protocol::T_SET, 6);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->exchangeMics.size()));
      std::set<std::string> ::const_iterator _iter79;
      for (_iter79 = this->exchangeMics.begin(); _iter79 != this->exchangeMics.end(); ++_iter79)
      {
        xfer += oprot->writeString((*_iter79));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ReqAccountCommodityRegisterAbilityOption &a, ReqAccountCommodityRegisterAbilityOption &b) {
  using ::std::swap;
  swap(a.registerAbilityId, b.registerAbilityId);
  swap(a.accountId, b.accountId);
  swap(a.sledCommodityIds, b.sledCommodityIds);
  swap(a.sledExchangeIds, b.sledExchangeIds);
  swap(a.supportType, b.supportType);
  swap(a.exchangeMics, b.exchangeMics);
  swap(a.__isset, b.__isset);
}

const char* QuotationAccountPage::ascii_fingerprint = "2DC51204CA1796654C4FE95071925837";
const uint8_t QuotationAccountPage::binary_fingerprint[16] = {0x2D,0xC5,0x12,0x04,0xCA,0x17,0x96,0x65,0x4C,0x4F,0xE9,0x50,0x71,0x92,0x58,0x37};

uint32_t QuotationAccountPage::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->total);
          this->__isset.total = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->page.clear();
            uint32_t _size80;
            ::apache::thrift::protocol::TType _etype83;
            xfer += iprot->readListBegin(_etype83, _size80);
            this->page.resize(_size80);
            uint32_t _i84;
            for (_i84 = 0; _i84 < _size80; ++_i84)
            {
              xfer += this->page[_i84].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.page = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t QuotationAccountPage::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("QuotationAccountPage");

  if (this->__isset.total) {
    xfer += oprot->writeFieldBegin("total", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->total);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.page) {
    xfer += oprot->writeFieldBegin("page", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->page.size()));
      std::vector<QuotationAccount> ::const_iterator _iter85;
      for (_iter85 = this->page.begin(); _iter85 != this->page.end(); ++_iter85)
      {
        xfer += (*_iter85).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(QuotationAccountPage &a, QuotationAccountPage &b) {
  using ::std::swap;
  swap(a.total, b.total);
  swap(a.page, b.page);
  swap(a.__isset, b.__isset);
}

const char* ContractActiveRulePage::ascii_fingerprint = "A99F0E6CB95B2926B796492948D7F6BF";
const uint8_t ContractActiveRulePage::binary_fingerprint[16] = {0xA9,0x9F,0x0E,0x6C,0xB9,0x5B,0x29,0x26,0xB7,0x96,0x49,0x29,0x48,0xD7,0xF6,0xBF};

uint32_t ContractActiveRulePage::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->total);
          this->__isset.total = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->page.clear();
            uint32_t _size86;
            ::apache::thrift::protocol::TType _etype89;
            xfer += iprot->readListBegin(_etype89, _size86);
            this->page.resize(_size86);
            uint32_t _i90;
            for (_i90 = 0; _i90 < _size86; ++_i90)
            {
              xfer += this->page[_i90].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.page = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ContractActiveRulePage::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ContractActiveRulePage");

  if (this->__isset.total) {
    xfer += oprot->writeFieldBegin("total", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->total);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.page) {
    xfer += oprot->writeFieldBegin("page", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->page.size()));
      std::vector<ContractActiveRule> ::const_iterator _iter91;
      for (_iter91 = this->page.begin(); _iter91 != this->page.end(); ++_iter91)
      {
        xfer += (*_iter91).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ContractActiveRulePage &a, ContractActiveRulePage &b) {
  using ::std::swap;
  swap(a.total, b.total);
  swap(a.page, b.page);
  swap(a.__isset, b.__isset);
}

const char* ContractRegisterRulePage::ascii_fingerprint = "E85F686AA9398009E26A10442CC8CC79";
const uint8_t ContractRegisterRulePage::binary_fingerprint[16] = {0xE8,0x5F,0x68,0x6A,0xA9,0x39,0x80,0x09,0xE2,0x6A,0x10,0x44,0x2C,0xC8,0xCC,0x79};

uint32_t ContractRegisterRulePage::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->total);
          this->__isset.total = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->page.clear();
            uint32_t _size92;
            ::apache::thrift::protocol::TType _etype95;
            xfer += iprot->readListBegin(_etype95, _size92);
            this->page.resize(_size92);
            uint32_t _i96;
            for (_i96 = 0; _i96 < _size92; ++_i96)
            {
              xfer += this->page[_i96].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.page = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ContractRegisterRulePage::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ContractRegisterRulePage");

  if (this->__isset.total) {
    xfer += oprot->writeFieldBegin("total", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->total);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.page) {
    xfer += oprot->writeFieldBegin("page", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->page.size()));
      std::vector<ContractRegisterRule> ::const_iterator _iter97;
      for (_iter97 = this->page.begin(); _iter97 != this->page.end(); ++_iter97)
      {
        xfer += (*_iter97).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ContractRegisterRulePage &a, ContractRegisterRulePage &b) {
  using ::std::swap;
  swap(a.total, b.total);
  swap(a.page, b.page);
  swap(a.__isset, b.__isset);
}

const char* ReqContractActiveRuleOption::ascii_fingerprint = "96F0FADC707FB83F158E6B9228D6FC5E";
const uint8_t ReqContractActiveRuleOption::binary_fingerprint[16] = {0x96,0xF0,0xFA,0xDC,0x70,0x7F,0xB8,0x3F,0x15,0x8E,0x6B,0x92,0x28,0xD6,0xFC,0x5E};

uint32_t ReqContractActiveRuleOption::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->commodityIds.clear();
            uint32_t _size98;
            ::apache::thrift::protocol::TType _etype101;
            xfer += iprot->readSetBegin(_etype101, _size98);
            uint32_t _i102;
            for (_i102 = 0; _i102 < _size98; ++_i102)
            {
              int32_t _elem103;
              xfer += iprot->readI32(_elem103);
              this->commodityIds.insert(_elem103);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.commodityIds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ReqContractActiveRuleOption::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ReqContractActiveRuleOption");

  if (this->__isset.commodityIds) {
    xfer += oprot->writeFieldBegin("commodityIds", ::apache::thrift::protocol::T_SET, 1);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->commodityIds.size()));
      std::set<int32_t> ::const_iterator _iter104;
      for (_iter104 = this->commodityIds.begin(); _iter104 != this->commodityIds.end(); ++_iter104)
      {
        xfer += oprot->writeI32((*_iter104));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ReqContractActiveRuleOption &a, ReqContractActiveRuleOption &b) {
  using ::std::swap;
  swap(a.commodityIds, b.commodityIds);
  swap(a.__isset, b.__isset);
}

const char* ReqContractRegisterRuleOption::ascii_fingerprint = "C653CC17D12232F67733876F567ABC34";
const uint8_t ReqContractRegisterRuleOption::binary_fingerprint[16] = {0xC6,0x53,0xCC,0x17,0xD1,0x22,0x32,0xF6,0x77,0x33,0x87,0x6F,0x56,0x7A,0xBC,0x34};

uint32_t ReqContractRegisterRuleOption::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->commodityIds.clear();
            uint32_t _size105;
            ::apache::thrift::protocol::TType _etype108;
            xfer += iprot->readSetBegin(_etype108, _size105);
            uint32_t _i109;
            for (_i109 = 0; _i109 < _size105; ++_i109)
            {
              int32_t _elem110;
              xfer += iprot->readI32(_elem110);
              this->commodityIds.insert(_elem110);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.commodityIds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast111;
          xfer += iprot->readI32(ecast111);
          this->platformEnv = (QuotationPlatformEnv::type)ecast111;
          this->__isset.platformEnv = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ReqContractRegisterRuleOption::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ReqContractRegisterRuleOption");

  if (this->__isset.commodityIds) {
    xfer += oprot->writeFieldBegin("commodityIds", ::apache::thrift::protocol::T_SET, 1);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->commodityIds.size()));
      std::set<int32_t> ::const_iterator _iter112;
      for (_iter112 = this->commodityIds.begin(); _iter112 != this->commodityIds.end(); ++_iter112)
      {
        xfer += oprot->writeI32((*_iter112));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.platformEnv) {
    xfer += oprot->writeFieldBegin("platformEnv", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32((int32_t)this->platformEnv);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ReqContractRegisterRuleOption &a, ReqContractRegisterRuleOption &b) {
  using ::std::swap;
  swap(a.commodityIds, b.commodityIds);
  swap(a.platformEnv, b.platformEnv);
  swap(a.__isset, b.__isset);
}

const char* ReqQuotationAccountOption::ascii_fingerprint = "0E522FD106CED5DB9002E8C001A1592A";
const uint8_t ReqQuotationAccountOption::binary_fingerprint[16] = {0x0E,0x52,0x2F,0xD1,0x06,0xCE,0xD5,0xDB,0x90,0x02,0xE8,0xC0,0x01,0xA1,0x59,0x2A};

uint32_t ReqQuotationAccountOption::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->accountIds.clear();
            uint32_t _size113;
            ::apache::thrift::protocol::TType _etype116;
            xfer += iprot->readSetBegin(_etype116, _size113);
            uint32_t _i117;
            for (_i117 = 0; _i117 < _size113; ++_i117)
            {
              int64_t _elem118;
              xfer += iprot->readI64(_elem118);
              this->accountIds.insert(_elem118);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.accountIds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast119;
          xfer += iprot->readI32(ecast119);
          this->platform = (QuotationTechPlatform::type)ecast119;
          this->__isset.platform = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast120;
          xfer += iprot->readI32(ecast120);
          this->platformEnv = (QuotationPlatformEnv::type)ecast120;
          this->__isset.platformEnv = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->supportCommodityIds.clear();
            uint32_t _size121;
            ::apache::thrift::protocol::TType _etype124;
            xfer += iprot->readSetBegin(_etype124, _size121);
            uint32_t _i125;
            for (_i125 = 0; _i125 < _size121; ++_i125)
            {
              int32_t _elem126;
              xfer += iprot->readI32(_elem126);
              this->supportCommodityIds.insert(_elem126);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.supportCommodityIds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->brokerIds.clear();
            uint32_t _size127;
            ::apache::thrift::protocol::TType _etype130;
            xfer += iprot->readSetBegin(_etype130, _size127);
            uint32_t _i131;
            for (_i131 = 0; _i131 < _size127; ++_i131)
            {
              int32_t _elem132;
              xfer += iprot->readI32(_elem132);
              this->brokerIds.insert(_elem132);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.brokerIds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->accountNamePartical);
          this->__isset.accountNamePartical = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nickNamePartical);
          this->__isset.nickNamePartical = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast133;
          xfer += iprot->readI32(ecast133);
          this->orderBy = (QuotationAccountOrderBy::type)ecast133;
          this->__isset.orderBy = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ReqQuotationAccountOption::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ReqQuotationAccountOption");

  if (this->__isset.accountIds) {
    xfer += oprot->writeFieldBegin("accountIds", ::apache::thrift::protocol::T_SET, 1);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->accountIds.size()));
      std::set<int64_t> ::const_iterator _iter134;
      for (_iter134 = this->accountIds.begin(); _iter134 != this->accountIds.end(); ++_iter134)
      {
        xfer += oprot->writeI64((*_iter134));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.platform) {
    xfer += oprot->writeFieldBegin("platform", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32((int32_t)this->platform);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.platformEnv) {
    xfer += oprot->writeFieldBegin("platformEnv", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32((int32_t)this->platformEnv);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.supportCommodityIds) {
    xfer += oprot->writeFieldBegin("supportCommodityIds", ::apache::thrift::protocol::T_SET, 4);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->supportCommodityIds.size()));
      std::set<int32_t> ::const_iterator _iter135;
      for (_iter135 = this->supportCommodityIds.begin(); _iter135 != this->supportCommodityIds.end(); ++_iter135)
      {
        xfer += oprot->writeI32((*_iter135));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.brokerIds) {
    xfer += oprot->writeFieldBegin("brokerIds", ::apache::thrift::protocol::T_SET, 5);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->brokerIds.size()));
      std::set<int32_t> ::const_iterator _iter136;
      for (_iter136 = this->brokerIds.begin(); _iter136 != this->brokerIds.end(); ++_iter136)
      {
        xfer += oprot->writeI32((*_iter136));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.accountNamePartical) {
    xfer += oprot->writeFieldBegin("accountNamePartical", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->accountNamePartical);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.nickNamePartical) {
    xfer += oprot->writeFieldBegin("nickNamePartical", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->nickNamePartical);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.orderBy) {
    xfer += oprot->writeFieldBegin("orderBy", ::apache::thrift::protocol::T_I32, 8);
    xfer += oprot->writeI32((int32_t)this->orderBy);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ReqQuotationAccountOption &a, ReqQuotationAccountOption &b) {
  using ::std::swap;
  swap(a.accountIds, b.accountIds);
  swap(a.platform, b.platform);
  swap(a.platformEnv, b.platformEnv);
  swap(a.supportCommodityIds, b.supportCommodityIds);
  swap(a.brokerIds, b.brokerIds);
  swap(a.accountNamePartical, b.accountNamePartical);
  swap(a.nickNamePartical, b.nickNamePartical);
  swap(a.orderBy, b.orderBy);
  swap(a.__isset, b.__isset);
}


